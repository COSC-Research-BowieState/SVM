#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 10 22:44:40 2018

@author: hkyeremateng-boateng
"""
import random
import math
import cmath
import numpy as np
import matplotlib.pyplot as plt
import csv
from scipy import special
import pandas as pd

pi = math.pi
lambda1 = 0.005 #arrival rate per sample
lambda2 = 0.005 #survival rate per sample
kParam1 = 2 #k-parameter for Erlang/gamma distribution (ON)
kParam2 = 2 #k-parameter for Erlang/gamma distribution (OFF)
var1 = lambda1 #variance parameter for log-normal distribution (ON)
var2 = lambda2 #variance parameter for log-normal distribution (OFF)
N = 3000 #number of samples
occupancy = [0]*N
stateTrans = [] #tracks alternating states [1,0,1,0,1,0,...]
intTimes = [] #tracks intervals
upTimes = []
downTimes = []
intTimesSeq = [] #counts and tracks intervals
upDist = "lnorm"    #'exp', 'erl', or 'lnorm'
downDist = "lnorm"  #'exp', 'erl', or 'lnorm'

#process initialized to "on"

totalTime = 0 #tracks total time generated by the ARP
seqState = 1 #tracks next state to generate

while totalTime < N:
    #generates on sequence
    if seqState:
        #generates random on period
        if upDist=="exp":
            period = math.ceil(random.expovariate(lambda1))
        elif upDist=="erl":
            period = math.ceil(random.gammavariate(kParam1,1/lambda1)) #assumes k=2
        elif upDist=="lnorm":
            trueMu = math.log(((1/lambda1)**2)/math.sqrt((1/var1)+(1/lambda1)**2))
            trueSig = math.sqrt(math.log((1/var1)/((1/lambda1)**2)+1))
            period = math.ceil(random.lognormvariate(trueMu,trueSig)) 
        #period = 5
        
        if (totalTime+period) > N: #makes sure total time isn't exceeded
            occupancy[totalTime:N] = [1]*(N-totalTime)
        else: #appends proper sequence of 1s
            occupancy[totalTime:totalTime+period] = [1]*period
            
        #tracks state transitions and on/off durations    
        stateTrans.append(1)
        intTimes.append(period)
        upTimes.append(period)
        intTimesSeq.append(list(range(1,period+1)))
        seqState = 0
        
    #generates off sequence
    else:
        #generates random off period
        if downDist=="exp":
            period = math.ceil(random.expovariate(lambda2))
        elif downDist=="erl":
            period = math.ceil(random.gammavariate(kParam2,1/lambda2)) #assumes k=2
        elif downDist=="lnorm":
            period = math.ceil(random.lognormvariate(lambda2,var2)) 
        #period = 10
        
        if (totalTime+period) > N: #makes sure total time isn't exceeded
            occupancy[totalTime:N] = [0]*(N-totalTime)
        else: #appends proper sequence of 1s
            occupancy[totalTime:totalTime+period] = [0]*period
        
        #tracks state transitions and on/off durations    
        stateTrans.append(0)
        intTimes.append(period)
        downTimes.append(period)
        intTimesSeq.append(list(range(1,period+1)))
        seqState = 1
        
    totalTime += period
    
seqSize = len(stateTrans) #total number of on and off states
traffic_intensity = sum(occupancy)/N #measures traffic intensity
#measures mean signal interarrival
mean_int = sum(intTimes[0:seqSize-(seqSize%2)]) / ((seqSize-(seqSize%2))/2) 
actual_int = 1/lambda1+1/lambda2 #calculates theoretical interarrival

#reactive predictor "accuracy/error"
predicted = occupancy[0:N-1]
#theoretical accuracy based on lambda parameters
theoAcc = 1-(2/actual_int-1/N)
#accuracy based on measured mean interarrival
expAcc = 1-(2/mean_int-1/N)
#observed accuracy
"""
result = [0]*(N-1)
for i in range(N-1):
    if predicted[i]==occupancy[i+1]:
        result[i]=1
obsAcc = sum(result)/(N-1)
"""
obsAcc = sum([predicted[i]==occupancy[i+1] for i in range(N-1)]) / (N-1)



###input RF signal generation###
dLen = 10 #length of the energy detector
fs = 100e6
time = [i/fs for i in range(N*dLen)]
powerLvl = -40 #power in dBm
amp = math.sqrt((10**(powerLvl/10))/1000 * (2*50)) #sinusoid amplitude
noiseVar = 1e-7 #noisefloor variance (1e-7 places noisefloor around -100 dBm)
noisefloor = [math.sqrt(noiseVar)*random.gauss(0,1) for i in range(N*dLen)]

sineWave = [amp*cmath.exp(1j*2*pi*(10e6)*time[i]) for i in range(N*dLen)] #sine wave at 10 MHz            
#SNR of the signal
SNR = 10*math.log10((sum([abs(sineWave[i])**2 for i in range(N*dLen)])/(dLen*N)) / (sum([abs(noisefloor[i])**2 for i in range(N*dLen)])/(dLen*N)))

#Modulates the sine wave with the occupancy state where each state has dLen samples
occSwitch = [occupancy[math.floor(i/dLen)] for i in range(N*dLen)]
inputRF = [sineWave[i]*occSwitch[i]+noisefloor[i] for i in range(N*dLen)]

P_fa = 0.01 #probability of false alarm

thresh = noiseVar/np.sqrt(dLen)*special.erfinv(P_fa)+noiseVar; 


#Calculates total average power over a sliding window
totalAvgPwr = np.zeros((1,dLen*N-dLen+1));
pwrStates = np.zeros((dLen,dLen*N-dLen+1));
t = dLen*N-dLen+1
for i in range(t):
    totalAvgPwr.itemset(i,sum(np.abs(inputRF[i:i+dLen-1])**2)/dLen)
    for k in  range(t, dLen):
        pwrStates.itemset((i,k-1),k)

#Observed states based on energy detector
obsState = totalAvgPwr > thresh;
plt.plot(np.array([i for i in range(dLen*N-dLen+1)]),10*np.log10(thresh*np.ones(np.size(totalAvgPwr)))-30)
 
###############################################################################################################################
N_train = dLen*N//2-dLen+1; #training data length - 149901

N_test = dLen*N//2; #test data length - 150000
N = N_train+N_test; #total data length - 299901

#Training label ground truth/target
wLen = 5*dLen; 
#input window length
trainLbl = np.zeros((1,N_train));
for i in range(N_train):
    trainLbl.itemset(i,totalAvgPwr[0,i]);
#Traing and test input data
trainData = np.zeros((wLen,N_train));
testData = np.zeros((wLen,N_test-wLen));
#totalAvgPwr is one-dimensional array
#trainData in a multi-dimensional array
for i in range(N_train-1):
    for k in  range(i-wLen+1):
        trainData.itemset((k,i),totalAvgPwr[0,i-wLen+1])


for i in range(wLen):
    #Input consists of present state and wLen previous states
    for k in  range(N_train-wLen):
        testData.itemset((i,k),totalAvgPwr[i-wLen+1+N_train,i+N_train])       